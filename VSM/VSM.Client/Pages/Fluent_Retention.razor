@page "/fluent_retention"
@rendermode InteractiveAuto
@using Microsoft.FluentUI.AspNetCore.Components
@using VSM.Client.Datamodel

<h3>Retention settings</h3>

<FluentStack Orientation="Orientation.Vertical">
    <FluentBodyContent>
        <hr/>
        <div class="grid">
            @if (isLoading)
            {
                <div style="display: flex; flex-direction: column; align-items: center; justify-content: center; height: 400px; text-align: center;">
                    <FluentProgressRing Width="128px"></FluentProgressRing>
                    <div style="margin-top: 16px; font-size: 16px;">
                        Loading folder tree...
                    </div>
                </div>
            } else {
            
                <FluentDataGrid @ref="grid" Items="@VisibleRows.AsQueryable()" TGridItem="TreeNode" Virtualize="true" ItemSize ="25" 
                                ShowHover="true" DisplayMode="DataGridDisplayMode.Table" GenerateHeader="@GenerateHeaderOption.Sticky">

                        <TemplateColumn TGridItem="TreeNode" Title="TreeNodes" Width="350px">
                            <ChildContent Context="item">
                                <div style="padding-left:@(item.Level * 15)px;">
                                    @if (item is InnerNode innerNode && innerNode.Children.Count() > 0)
                                    {
                                        <button class="e-flat" @onclick="() => ToggleExpand(item)">
                                            @(item.IsExpanded ? "▾" : "▸")
                                        </button>
                                    }
                                    @item.Name
                            </div>
                            </ChildContent>
                        </TemplateColumn>                                

                        @if( rootFolder!=null ){
                            @foreach (var key in rootFolder.RetentionHeaders)
                            {
                                <TemplateColumn TGridItem="TreeNode" Title="@key">
                                    <ChildContent Context="item">
                                        @if( item.AttributDict.TryGetValue(key, out var val) ){
                                            RetentionCell cell = new RetentionCell(item,key);    
                                            //var cellId = $"{item.Id}_{key}";

                                            var isSelected  = selected_cell==null ? false : selected_cell == cell ;
                                            var buttonClass = isSelected ? "e-flat selected" : "e-flat";

                                            <button class="@buttonClass" @onclick="() => OnCellClick(item, key)">
                                                @val
                                            </button>
                                        }
                                    </ChildContent>
                                </TemplateColumn>
                            }
                        }

                    </FluentDataGrid>
        }                
        </div>
    </FluentBodyContent>
    <FluentStack Orientation="Orientation.Vertical" Style="margin-top: 20px;">
        <hr />
        <h2> Review and change retention</h2>
        @if( selected_cell != null ){
            <div style="display: flex; align-items: center; gap: 10px;">
                <span>TreeNode: </span>
                <span>@selected_cell.TreeNode.Name</span>
            </div>            
            <div style="display: flex; align-items: center; gap: 10px;">
                <span>Current retention: </span>
                <span>@selected_cell.retention_key</span>
            </div>            
            <div style="display: flex; align-items: center; gap: 10px;">
                
                <FluentCombobox Placeholder="Make a selection..." 
                                Label="New retention" 
                                Autofocus="true"
                                Multiple=false
                                Items="@retentionOptions"
                                @bind-Value="@selected_cell.new_retention_key"
                                @bind-Value:after="OnRetentionChangedAsync" 
                                Height="200px"
                                Position="SelectPosition.Above" 
                                Immediate ImmediateDelay="100"
                                Disabled="@isProcessing" />
            </div>
            @if (isProcessing)
            {
                <div style="margin-top: 10px;">
                    <FluentProgress Text="Updating retention settings..." />
                </div>
            }
        }
    </FluentStack>
</FluentStack>

@code {
    FluentDataGrid<TreeNode>? grid;
    private List<TreeNode> TreeRoots = new();
    private List<TreeNode> VisibleRows = new();
    public  RootFolder? rootFolder { get; set; }
    public List<string> retentionOptions { get { return DataModel.Instance.RetentionOptions; } }
    private bool isLoading = true;
    private bool hasRendered = false;
    
    protected override void OnInitialized()
    {
        // Just set up initial state, don't block with async operations
        if( rootFolder != DataModel.Instance.GetSelectedRootFolder() ) 
        {
            rootFolder = DataModel.Instance.GetSelectedRootFolder(); 
            // Don't await here - let the UI render first
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender && !hasRendered)
        {
            hasRendered = true;
            // Now load data after the UI has rendered
            await LoadDataAsync();
        }
    }

    private async Task LoadDataAsync()
    {
        try
        {
            // Ensure UI shows loading state
            await InvokeAsync(StateHasChanged);
            
            if( rootFolder != null ){
                var folderTree = await rootFolder.GetFolderTreeAsync();
                if( folderTree == null ){
                    TreeRoots.Clear();
                } else if( folderTree is InnerNode innerNode ) {
                    TreeRoots = innerNode.Children;
                }

                if( folderTree != null )
                    await folderTree.UpdateAggregation();
            }            
        }
        finally
        {
            RefreshVisibleRows();
            isLoading = false;
            await InvokeAsync(StateHasChanged);
        }
    }
    
    private void ToggleExpand(TreeNode node)
    {
        node.IsExpanded = !node.IsExpanded;
        RefreshVisibleRows();
    }

    private void RefreshVisibleRows()
    {
        VisibleRows = FlattenVisible(TreeRoots);
    }

    private List<TreeNode> FlattenVisible(IEnumerable<TreeNode> nodes)
    {
        var result = new List<TreeNode>();
        foreach (var node in nodes)
        {
            result.Add(node);
            if (node.IsExpanded && node is InnerNode innerNode)
            {
                result.AddRange(FlattenVisible(innerNode.Children));
            }
        }

        return result;
    }

    public class RetentionCell : IEquatable<RetentionCell>
    {
        public TreeNode TreeNode { get; set; }
        public string retention_key { get; set; }
        public string new_retention_key { get; set; }
        public RetentionCell(TreeNode TreeNode, string retention_key)
        {
            this.TreeNode = TreeNode;
            this.retention_key = retention_key;
            this.new_retention_key = this.retention_key; 
        }
        public bool Equals(RetentionCell? other)
        {
            if (other is null) return false;
            if (ReferenceEquals(this, other)) return true;
            
            return TreeNode?.Id == other.TreeNode?.Id && 
                string.Equals(retention_key, other.retention_key, StringComparison.Ordinal);
        }
        public override bool Equals(object? obj)
        {
            return obj is RetentionCell other && Equals(other);
        }
        public override int GetHashCode()
        {
            return HashCode.Combine(TreeNode?.Id, retention_key);
        }

        public static bool operator ==(RetentionCell? left, RetentionCell? right)
        {
            if (left is null) return right is null;
            return left.Equals(right);
        }

        public static bool operator !=(RetentionCell? left, RetentionCell? right)
        {
            return !(left == right);
        }

        public async Task SyncRetentions()
        {
            if( new_retention_key != retention_key ){
                Console.WriteLine($"sync the TreeNode tree' retentions {TreeNode.Name} retention {retention_key} new_retention {new_retention_key}");
                
                if( TreeNode is InnerNode innerNode )
                    innerNode.ChangeLeafRetentions(retention_key, new_retention_key);
                else if( TreeNode is LeafNode leafNode )
                    leafNode.Retention = new_retention_key;
                
                retention_key = new_retention_key;

                //finde the root folder by iteration untill the parent is null
                var currentFolder = TreeNode;
                while (currentFolder.Parent !=  null)
                {
                    currentFolder = currentFolder.Parent;
                }
                if( currentFolder is InnerNode  currentFolderInnerNode )
                    await currentFolderInnerNode.UpdateAggregation();
            }
        }
    }
    RetentionCell? selected_cell = null;
    private bool isProcessing = false;

    
    private void OnCellClick(TreeNode node, string key)
    {
        //selected_cell = (node,key);
        selected_cell = new RetentionCell(node,key);
        Console.WriteLine($"Cell focused, clickCount: {node.Name}, {key}");
    }

    private async Task OnRetentionChangedAsync()
    {
        if (selected_cell != null)
        {
            isProcessing = true;
            StateHasChanged(); // Update UI to show progress
            
            try
            {
                await selected_cell.SyncRetentions();
                await InvokeAsync(StateHasChanged);
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error syncing retentions: {ex.Message}");
            }
            finally
            {
                isProcessing = false;
                StateHasChanged(); // Hide progress indicator
            }
        }
    }
}
