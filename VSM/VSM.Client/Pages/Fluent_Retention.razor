@page "/fluent_retention"
@rendermode InteractiveAuto
@using Microsoft.FluentUI.AspNetCore.Components
@using VSM.Client.Datamodel

<h3>Retention settings</h3>

<FluentStack Orientation="Orientation.Vertical">
    <FluentBodyContent>
        <hr/>
        <div class="grid">
                <FluentDataGrid @ref="grid" Items="@VisibleRows.AsQueryable()" TGridItem="Folder" Virtualize="true" ItemSize ="25" 
                                ShowHover="true" DisplayMode="DataGridDisplayMode.Table" GenerateHeader="@GenerateHeaderOption.Sticky">

                    <TemplateColumn TGridItem="Folder" Title="Folders" Width="350px">
                        <ChildContent Context="item">
                            <div style="padding-left:@(item.Level * 15)px;">
                                @if (item.Children.Count() > 0)
                                {
                                    <button class="e-flat" @onclick="() => ToggleExpand(item)">
                                        @(item.IsExpanded ? "▾" : "▸")
                                    </button>
                                }
                                @item.Name
                        </div>
                        </ChildContent>
                    </TemplateColumn>                                

                    @if( rootFolder!=null ){
                        @foreach (var key in rootFolder.RetentionHeaders)
                        {
                            <TemplateColumn TGridItem="Folder" Title="@key">
                                <ChildContent Context="item">
                                    @if( item.AttributDict.TryGetValue(key, out var val) ){
                                        RetentionCell cell = new RetentionCell(item,key);    
                                        //var cellId = $"{item.Id}_{key}";

                                        var isSelected  = selected_cell==null ? false : selected_cell == cell ;
                                        var buttonClass = isSelected ? "e-flat selected" : "e-flat";

                                        <button class="@buttonClass" @onclick="() => OnCellClick(item, key)">
                                            @val
                                        </button>
                                    }
                                </ChildContent>
                            </TemplateColumn>
                        }
                    }

                </FluentDataGrid>
        </div>
    </FluentBodyContent>
    <FluentBodyContent>
        <hr />
        <h2> Review and change retention</h2>
        @if( selected_cell != null ){
            <div style="display: flex; align-items: center; gap: 10px;">
                <span>Folder: </span>
                <span>@selected_cell.folder.Name</span>
            </div>            
            <div style="display: flex; align-items: center; gap: 10px;">
                <span>Current retention: </span>
                <span>@selected_cell.retention_key</span>
            </div>            
            <div style="display: flex; align-items: center; gap: 10px;">
                
                <FluentCombobox Placeholder="Make a selection..." 
                                Label="New retention" 
                                Autofocus="true"
                                Multiple=false
                                Items="@retentionOptions"
                                @bind-Value="@selected_cell.new_retention_key"
                                @bind-Value:after="OnRetentionChangedAsync" 
                                Height="200px" 
                                Immediate ImmediateDelay="100"
                                Disabled="@isProcessing" />
            </div>
            @if (isProcessing)
            {
                <div style="margin-top: 10px;">
                    <FluentProgress Text="Updating retention settings..." />
                </div>
            }
        }

    </FluentBodyContent>
</FluentStack>

@code {

    FluentDataGrid<Folder>? grid;
    private List<Folder> TreeRoots = new();
    private List<Folder> VisibleRows = new();
    public  RootFolder? rootFolder { get; set; }
    public List<string> retentionOptions { get { return DataModel.Instance.RetentionOptions; } }
    
    protected override void OnInitialized()
    {
        //looks like OnInitialized is called twice so lets check if we have already processed the root folder
        if( rootFolder != DataModel.Instance.GetSelectedRootFolder() ) 
        {
            rootFolder = DataModel.Instance.GetSelectedRootFolder(); 
            if( rootFolder.FolderTree == null ){
                TreeRoots.Clear() ;
            } else {
                TreeRoots = rootFolder.FolderTree.Children;
            }

            if( rootFolder.FolderTree != null )
                rootFolder.FolderTree.UpdateAggregation(); 

        }
        RefreshVisibleRows();
    }

    private void ToggleExpand(Folder node)
    {
        node.IsExpanded = !node.IsExpanded;
        RefreshVisibleRows();
    }

    private void RefreshVisibleRows()
    {
        VisibleRows = FlattenVisible(TreeRoots);
    }

    private List<Folder> FlattenVisible(IEnumerable<Folder> nodes)
    {
        var result = new List<Folder>();
        foreach (var node in nodes)
        {
            result.Add(node);
            if (node.IsExpanded)
            {
                result.AddRange(FlattenVisible(node.Children));
            }
        }

        return result;
    }



    public class RetentionCell : IEquatable<RetentionCell>
    {
        public Folder? folder { get; set; }
        public string? retention_key { get; set; }
        public string? new_retention_key { get; set; }
        public RetentionCell(Folder? folder, string? retention_key)
        {
            this.folder = folder;
            this.retention_key = retention_key;
            this.new_retention_key = this.retention_key; 
        }
        public bool Equals(RetentionCell? other)
        {
            if (other is null) return false;
            if (ReferenceEquals(this, other)) return true;
            
            return folder?.Id == other.folder?.Id && 
                string.Equals(retention_key, other.retention_key, StringComparison.Ordinal);
        }
        public override bool Equals(object? obj)
        {
            return obj is RetentionCell other && Equals(other);
        }

        public override int GetHashCode()
        {
            return HashCode.Combine(folder?.Id, retention_key);
        }

        public static bool operator ==(RetentionCell? left, RetentionCell? right)
        {
            if (left is null) return right is null;
            return left.Equals(right);
        }

        public static bool operator !=(RetentionCell? left, RetentionCell? right)
        {
            return !(left == right);
        }

        public async Task SyncRetentions()
        {
            if( new_retention_key != retention_key ){
                Console.WriteLine($"sync the folder tree' retentions {folder.Name} retention {retention_key} new_retention {new_retention_key}");
                await Task.Delay(4000);
                retention_key = new_retention_key;
            } 
        }
    }
    RetentionCell selected_cell = null;
    private bool isProcessing = false;

    
    private void OnCellClick(Folder node, string key)
    {
        //selected_cell = (node,key);
        selected_cell = new RetentionCell(node,key);
        Console.WriteLine($"Cell focused, clickCount: {node.Name}, {key}");
    }

    private async Task OnRetentionChangedAsync()
    {
        if (selected_cell != null)
        {
            isProcessing = true;
            StateHasChanged(); // Update UI to show progress
            
            try
            {
                await selected_cell.SyncRetentions();
                await InvokeAsync(StateHasChanged);
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error syncing retentions: {ex.Message}");
            }
            finally
            {
                isProcessing = false;
                StateHasChanged(); // Hide progress indicator
            }
        }
    }
}
